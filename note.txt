babel - es6+ 코드를 es5 이하 버전으로 트랜스 파일링 해준다.
구형 브라우저에서 지원하지 않는 코드를 IE나 구형 브라우저에서 동작하도록 만들기 위해서
ES6+코드를 ES5이하 버전으로 변환 해준다.

middleware - 처리가 끝날때까지 연결되어 있는것
express에서 모든 함수는 미들웨어가 될수 있다.
user와 end 사이에 원하는 만큼 넣을수 있다.

morgan - logger middleware
helmet - secure middleware
cookie-parser - 요청된 쿠키를 쉽게 추출할 수 있도록 해주는 미들웨어
cookie를 전달받아서 사용할수 있도록 만들어주는 미들웨어,
사용자 인증 같은 곳에서 쿠키를  검사할때 사용
body-parser - 클라이언트 POST requset data의 body로부터 파리미터를 편리하게 추출해준다.
사용자가 웹사이트로 전달하는 정보들을 검사하는 미들웨어,
requsest 정보에서 form이나 json 형태로 된 body 를 검사한다.

export default app;
import app from "./app.js";
export default는 파일로 export 한다는거다.

export const userRouter = express.RouteR(); 는 오직 이 변수만 export 한다는 거다.
import { userRouter } from "./router.js";

app.use("/user", userRouter);
app.use에서 use는 이 router전체를 사용하겠다는 의미다.

MVC
M - data
V - how does the data look
C - function that looks for the data

arrow function

function lalala () {
    return true
}

lalala = () => true

lalala = () => {
    return true
}

대괄호가 없으면 암시적으로 return해주지만,
대괄호를 넣어주면 return 하지 않는다.


pug 사용법 - https://dydals5678.tistory.com/91
pug에서 텍스트 사이에 자바스크립트를 추가해주고 싶다면
#{}사이에 넣어주면 된다.

layout을 통하여 반복되는 부분을 최소화 할수 있다.
block content를 통하여 원하는 부분만 변화게 할수있다.

extends layouts/main

block content
    p join

partials를 통하여 다룬파일을 이 pug에 가져올수 있다
include는 그냥 있는 그대로 껴넣음
block는 상속 비슷한것을 받아야 하지만 partials는 그대로 가능

locals에 있는 것은 템플릿에 변수명 처럼 존재한다.
locals에 로컬 변수를 저장하면 이 변수들을 템플릿에서 사용할 수 있다.
전역적으로(글로벌) 사용할 수 있는 변수를 추가 하는 방법
모든 템플릿에서 사용가능(템플릿, 뷰, 모든곳에서 사용 가능)
코드 사이에 들어있어서 next()를 호출 해야한다.(다음함수(미들웨어)로 넘겨주기 위해서)

전역범위에 변수를 추가하는 것이 아닌 한 템플릿에만 추가
render함수의 첫번째 인자는 템플릿
두번쨰 인자는 템플릿에 추가할 정보가 담긴 객체
export const home = (req, res) => res.render("home", { pageTitle: "Home" });
전달하고 싶은것은 무엇이든지 전달 가능하다.
export const home = (req, res) => res.render("home", { pageTitle: "Home",  potato: 1234 });

form추가
action은 /search인데 routes.search로 적어줘도 됨
method는 get으로(이래야 url에 정보가 표시됨 post면 안보임)
input에 name을 추가해줘야 url에 정보가 표시됨

es6 이전
const searchingBy = req.query.term;
es6 - 둘은 동일하다
const { query: { term } } = req;
term에 변수명을 할당하고싶으면 아래와 같이 해주면 된다.
const {
  query: { term: searchingBy }
} = req;

res.render("search", { pageTitle: "Search", searchingBy });

get요청을 보냈을때 해당하는 컨트롤러만 있을때 mtehod="post"를 해주면 에러가 난다.

User Detail라고 뜬 이유는 /edit-profile을 /:id 로 인식해서 그렇다.
userRouter에 가서 순서를 바꿔주면 된다.(editProfile, changePassword가 더 위에 오도록)

express는 /:id/edit을 이해할수 있지만 링크는 /videos/:id/delete로 그대로 표시됨
id의 값이 변해야 하는데 변하지 않는다 이를 해결해야함

homeController에서 videos 배열 전달하기
import { videos } from "../db";
export const home = (req, res) => {
  res.render("home", { pageTitle: "Home", videos });
};

videos배열에서 하나씩 template를 적용시킴
each video in videos
    h1= video.title
    p= item.discription

mixin
mixin은 웹사이에트에서 자주 반복되는 코드를 담고있다.

each item in videos
    +videoBlock({
        title: item.title,
        description: item.description
    })
이 정보들이 videoBlock으로 전달되어서 
mixin videoBlock(video = {})
    h1=video.title
    p=video.description
이 함수를 실행시킨다.
그리고 그 함수는 html로 내보낸다.

각각 다른 정보를 가지지만 같은 구조를 가지는 데이터를 표시하기 위한 코드를 캡슐화 했다.
이게 mixin을 사용하는 이유다. 다른정보, 같은구조
mixin videoBlock(video = {})
    .videoBlock
        video.videoBlock__thumbnail(src=video.videoFile, controls=true)
        h4.videoBlock__title=video.title
        h6.videoBlock__views=video.views

block content
    .videos
        each item in videos
            +videoBlock({
                title: item.title,
                views: item.views,
                videoFile: item.videoFile
            })

globalRouter.get(routes.join, getJoin);
globalRouter.post(routes.join, postJoin);
get과 post를 따로 만들어 줘야 한다.

res.status(400);
status는 http 상태 코드를 나타낸다
400은 Bad requset이다

Profile을 검사해보면 user/:id가 아닌 user/5 이런식으로 나오게 하고싶다
미들웨어에 설정된 id가 url에 들어가도록 할려면 routes를 수정해야한다.
express는 이해하지만 html은 저 routes를 이해하지 못하기 때문이다.

userDetail을 함수로 바꿔야 한다.
userDetail: USER_DETAIL

이 함수는 id를 인자로 받는다, id가 있다면 /users/${id}를 리턴한다.
  userDetail: id => {
    if (id) {
      return `/users/${id}`;
    } else {
      return USER_DETAIL;
    }
  },

userRouter도 수정해야한다.
선언만 해두면 안되고, 실제로 함수를 실행해야 한다.
userRouter.get(routes.userDetail, userDetail); --> 
userRouter.get(routes.userDetail(), userDetail);
이 경우에는 id를 인자로 해서 실행하지 않으니 /:id를 리턴 받는다.

하지만 템플릿에서는 인자 없이 실행하면 안된다.
a(href=routes.userDetail) Profile -->
a(href=routes.userDetail(user.id)) Profile
user.id를 입력해줘야 한다.

--------------------------------------------------------
MongoDB 설치
공홈들어가서 설치
환경변수 설정해줘야함
path에 
C:\Program Files\MongoDB\Server\4.0\bin
추가
Mongo를 JavaScript와 연결해보기
JavaScript에서 MongoDB와 연결하려면 Adapter를 통해서 해야한다.
JavaScript코드를 작성하고 싶으면 MongoDB로부터 Instruction을 받아야 한다.
이 역할을 Mongoose가 해준다.
mongoose는 NodeJS를 위한 Object Modeling이다
npm install mongoose

임시로 만들어둔 db.js를 지우고 진짜 MongoDB연결하기
Mongoose는 Database와 연결해주는것
MongoDB는 NoSQL 데이터베이스이고 특징은 규칙이 적고 엄청 유연

dotenv 설치

npm install dotenv

mongoose.connect();
여기에 우리한테 요청하는건 string으로 된 Database이다
어디에 Database가 저장되어 있는지 알려준다.

mongodb://localhost:포트번호/Database이름
mongoose.connect("mongodb://localhost:27017/we-tube");

새로운 버전의 mongoose는 Configuration(환경설정)을 보낼 수 있다.
mongoose.connect("mongodb://localhost:27017/we-tube", {
  useNewUrlParser: true, <--
  useFindAndModify: false <--
});

MongoDB와의 연결을 db로 저장 한 후
const db = mongoose.connection;

db.once("open", handleOpen);
once는 한번만 실행시키는것, 성공여부를 확인할수 있는 function을 만듬
const handleOpen = () => console.log("✅ Connected to DB");

init에  import "./db";  추가

dotenv
가끔 어떤 부분을 숨기고 싶을때
localhost에 db가 설치되어 있지만 다른곳에 설치된다면 어떨까?
코드에 있는 url로부터 유저 데이터를 보는걸 원하지 않는다

opensource프로젝트에서 db를 숨기고 싶을때 dotenv사용

dotenv.config 라는 함수로 .env 파일 엔에 있는 정보를 불러올 수 있다.
그리고 찾은 모든 variable 들을 process.env.key에 저장한다.

.env 파일을 .gitignore 파일에 추가해서 ignore하는걸 잊지마

MongoDB의 장점은 document를 줄여준다는것
MongoDB의 파일이 어떻게 생겼는지 알려줘야한다.(Model의 형태)

models란 폴더 생성후 Video.js를 만들어준다.
여기서 video의 형태를 정의한다.
해야할것은 model 즉 document name이고
다른 하나는 schema다, schema는 형태이다.
model은 그냥 실제 data이다.

const VideoSchema = new mongoose.Schema()
여기에 VideoSchema를 정의한다.

const VideoSchema = new mongoose.Schema({
  fileUrl: {
    type: String,
    required: "File URL is required"
  },
    views: {
    type: Number,
    default: 0
  },
    createdAt: {
    type: Date,
    default: Date.now
  }

fileUrl을 가지고 있으며 타입은 문자열
required가 충족되지 못하면 error msg는 File URL is required라 뜬다.
fileUrl 값이 없는 Video를 생성하면 error msg가 뜬다.

view의 타입은 숫자고이고
video가 처음 생성되면 views는 0이 되도록 설정

createdAt의 타입은 날자이고
처음 생성되면 현재의 날짜를 반환한다.

이제 이 스키마를 통해서 모델을 만들어보자
const model = mongoose.model("Video", VideoSchema);

model의 이름은 Video
Video model의 schema는 VideoSchema가 된다.

현재 database는 아직 인식하지를 못한다.
연결은 되어 있지만 거기에 model이 있는건 알지 못함.
init.js에 import 해줘야 한다.
import "./models/Video";

다음으로 알아야 할것은 data의 relationship이다.
comment에 video의 ID를 저장하거나
video가 ID의 array를 가지고 있어야 한다.

video에 comment를 달때 이 comment는 어떤 video와 직접적으로 연결되어 있는지?
두가지 방법이 있다.
한가지 방법은 여기 comment는 그대로 두고 
Video에선 모든 comment ID가 담긴 array를 추가하는거다.
object는 보통 id를 가지고 있다
따라서 모든 comment의 정보를 저장하는 대신 모든 video들이 comment id를 가지고 있는거다.
처음 video를 생성하면 comments는 0이다, 왜냐면 comment가 없기 때문
그다음 해당 video에 대한 comment를 생성하면 새로운 comment id를 video 안에 있는
comment의 list 라는 곳에 저장, 그리면 comments가 1이 된다.

Comment.js

video: {
  type: mongoose.Schema.Types.ObjectId,
  ref: "Video"
}

이 comment는 이 video와 연결되어 있고,
이 video의 type은 mongoose.Schema.Types.ObjectId
ObjectId가 어디서 온거인지 알려줘야 한다(어느 model인지)
이 경우에는 Video (ref: "Video")

두번째 방법은 ObjectId들의 array를 생성해야 한다.
ref는 Comment겠지

Video.js로 와서 comments 추가
comments: [
  {
    type: mongoose.Schema.Types.ObjectId,
    ref: "Comment"
  }
]