babel - es6+ 코드를 es5 이하 버전으로 트랜스 파일링 해준다.
구형 브라우저에서 지원하지 않는 코드를 IE나 구형 브라우저에서 동작하도록 만들기 위해서
ES6+코드를 ES5이하 버전으로 변환 해준다.

middleware - 처리가 끝날때까지 연결되어 있는것
express에서 모든 함수는 미들웨어가 될수 있다.
user와 end 사이에 원하는 만큼 넣을수 있다.

morgan - logger middleware
helmet - secure middleware
cookie-parser - 요청된 쿠키를 쉽게 추출할 수 있도록 해주는 미들웨어
cookie를 전달받아서 사용할수 있도록 만들어주는 미들웨어,
사용자 인증 같은 곳에서 쿠키를  검사할때 사용
body-parser - 클라이언트 POST requset data의 body로부터 파리미터를 편리하게 추출해준다.
사용자가 웹사이트로 전달하는 정보들을 검사하는 미들웨어,
requsest 정보에서 form이나 json 형태로 된 body 를 검사한다.

export default app;
import app from "./app.js";
export default는 파일로 export 한다는거다.

export const userRouter = express.RouteR(); 는 오직 이 변수만 export 한다는 거다.
import { userRouter } from "./router.js";

app.use("/user", userRouter);
app.use에서 use는 이 router전체를 사용하겠다는 의미다.

MVC
M - data
V - how does the data look
C - function that looks for the data

arrow function

function lalala () {
    return true
}

lalala = () => true

lalala = () => {
    return true
}

대괄호가 없으면 암시적으로 return해주지만,
대괄호를 넣어주면 return 하지 않는다.


pug 사용법 - https://dydals5678.tistory.com/91
pug에서 텍스트 사이에 자바스크립트를 추가해주고 싶다면
#{}사이에 넣어주면 된다.

layout을 통하여 반복되는 부분을 최소화 할수 있다.
block content를 통하여 원하는 부분만 변화게 할수있다.

extends layouts/main

block content
    p join

partials를 통하여 다룬파일을 이 pug에 가져올수 있다
include는 그냥 있는 그대로 껴넣음
block는 상속 비슷한것을 받아야 하지만 partials는 그대로 가능

locals에 있는 것은 템플릿에 변수명 처럼 존재한다.
locals에 로컬 변수를 저장하면 이 변수들을 템플릿에서 사용할 수 있다.
전역적으로(글로벌) 사용할 수 있는 변수를 추가 하는 방법
모든 템플릿에서 사용가능(템플릿, 뷰, 모든곳에서 사용 가능)
코드 사이에 들어있어서 next()를 호출 해야한다.(다음함수(미들웨어)로 넘겨주기 위해서)

전역범위에 변수를 추가하는 것이 아닌 한 템플릿에만 추가
render함수의 첫번째 인자는 템플릿
두번쨰 인자는 템플릿에 추가할 정보가 담긴 객체
export const home = (req, res) => res.render("home", { pageTitle: "Home" });
전달하고 싶은것은 무엇이든지 전달 가능하다.
export const home = (req, res) => res.render("home", { pageTitle: "Home",  potato: 1234 });

form추가
action은 /search인데 routes.search로 적어줘도 됨
method는 get으로(이래야 url에 정보가 표시됨 post면 안보임)
input에 name을 추가해줘야 url에 정보가 표시됨

es6 이전
const searchingBy = req.query.term;
es6 - 둘은 동일하다
const { query: { term } } = req;
term에 변수명을 할당하고싶으면 아래와 같이 해주면 된다.
const {
  query: { term: searchingBy }
} = req;

res.render("search", { pageTitle: "Search", searchingBy });

get요청을 보냈을때 해당하는 컨트롤러만 있을때 mtehod="post"를 해주면 에러가 난다.

User Detail라고 뜬 이유는 /edit-profile을 /:id 로 인식해서 그렇다.
userRouter에 가서 순서를 바꿔주면 된다.(editProfile, changePassword가 더 위에 오도록)

express는 /:id/edit을 이해할수 있지만 링크는 /videos/:id/delete로 그대로 표시됨
id의 값이 변해야 하는데 변하지 않는다 이를 해결해야함

homeController에서 videos 배열 전달하기
import { videos } from "../db";
export const home = (req, res) => {
  res.render("home", { pageTitle: "Home", videos });
};

videos배열에서 하나씩 template를 적용시킴
each video in videos
    h1= video.title
    p= item.discription

mixin
mixin은 웹사이에트에서 자주 반복되는 코드를 담고있다.

each item in videos
    +videoBlock({
        title: item.title,
        description: item.description
    })
이 정보들이 videoBlock으로 전달되어서 
mixin videoBlock(video = {})
    h1=video.title
    p=video.description
이 함수를 실행시킨다.
그리고 그 함수는 html로 내보낸다.

각각 다른 정보를 가지지만 같은 구조를 가지는 데이터를 표시하기 위한 코드를 캡슐화 했다.
이게 mixin을 사용하는 이유다. 다른정보, 같은구조
mixin videoBlock(video = {})
    .videoBlock
        video.videoBlock__thumbnail(src=video.videoFile, controls=true)
        h4.videoBlock__title=video.title
        h6.videoBlock__views=video.views

block content
    .videos
        each item in videos
            +videoBlock({
                title: item.title,
                views: item.views,
                videoFile: item.videoFile
            })

globalRouter.get(routes.join, getJoin);
globalRouter.post(routes.join, postJoin);
get과 post를 따로 만들어 줘야 한다.

res.status(400);
status는 http 상태 코드를 나타낸다
400은 Bad requset이다

Profile을 검사해보면 user/:id가 아닌 user/5 이런식으로 나오게 하고싶다
미들웨어에 설정된 id가 url에 들어가도록 할려면 routes를 수정해야한다.
express는 이해하지만 html은 저 routes를 이해하지 못하기 때문이다.

userDetail을 함수로 바꿔야 한다.
userDetail: USER_DETAIL

이 함수는 id를 인자로 받는다, id가 있다면 /users/${id}를 리턴한다.
  userDetail: id => {
    if (id) {
      return `/users/${id}`;
    } else {
      return USER_DETAIL;
    }
  },

userRouter도 수정해야한다.
선언만 해두면 안되고, 실제로 함수를 실행해야 한다.
userRouter.get(routes.userDetail, userDetail); --> 
userRouter.get(routes.userDetail(), userDetail);
이 경우에는 id를 인자로 해서 실행하지 않으니 /:id를 리턴 받는다.

하지만 템플릿에서는 인자 없이 실행하면 안된다.
a(href=routes.userDetail) Profile -->
a(href=routes.userDetail(user.id)) Profile
user.id를 입력해줘야 한다.

--------------------------------------------------------
MongoDB 설치
공홈들어가서 설치
환경변수 설정해줘야함
path에 
C:\Program Files\MongoDB\Server\4.0\bin
추가
Mongo를 JavaScript와 연결해보기
JavaScript에서 MongoDB와 연결하려면 Adapter를 통해서 해야한다.
JavaScript코드를 작성하고 싶으면 MongoDB로부터 Instruction을 받아야 한다.
이 역할을 Mongoose가 해준다.
mongoose는 NodeJS를 위한 Object Modeling이다
npm install mongoose

임시로 만들어둔 db.js를 지우고 진짜 MongoDB연결하기
Mongoose는 Database와 연결해주는것
MongoDB는 NoSQL 데이터베이스이고 특징은 규칙이 적고 엄청 유연

dotenv 설치

npm install dotenv

mongoose.connect();
여기에 우리한테 요청하는건 string으로 된 Database이다
어디에 Database가 저장되어 있는지 알려준다.

mongodb://localhost:포트번호/Database이름
mongoose.connect("mongodb://localhost:27017/we-tube");

새로운 버전의 mongoose는 Configuration(환경설정)을 보낼 수 있다.
mongoose.connect("mongodb://localhost:27017/we-tube", {
  useNewUrlParser: true, <--
  useFindAndModify: false <--
});

MongoDB와의 연결을 db로 저장 한 후
const db = mongoose.connection;

db.once("open", handleOpen);
once는 한번만 실행시키는것, 성공여부를 확인할수 있는 function을 만듬
const handleOpen = () => console.log("✅ Connected to DB");

init에  import "./db";  추가

dotenv
가끔 어떤 부분을 숨기고 싶을때
localhost에 db가 설치되어 있지만 다른곳에 설치된다면 어떨까?
코드에 있는 url로부터 유저 데이터를 보는걸 원하지 않는다

opensource프로젝트에서 db를 숨기고 싶을때 dotenv사용

dotenv.config 라는 함수로 .env 파일 엔에 있는 정보를 불러올 수 있다.
그리고 찾은 모든 variable 들을 process.env.key에 저장한다.

.env 파일을 .gitignore 파일에 추가해서 ignore하는걸 잊지마

MongoDB의 장점은 document를 줄여준다는것
MongoDB의 파일이 어떻게 생겼는지 알려줘야한다.(Model의 형태)

models란 폴더 생성후 Video.js를 만들어준다.
여기서 video의 형태를 정의한다.
해야할것은 model 즉 document name이고
다른 하나는 schema다, schema는 형태이다.
model은 그냥 실제 data이다.

const VideoSchema = new mongoose.Schema()
여기에 VideoSchema를 정의한다.

const VideoSchema = new mongoose.Schema({
  fileUrl: {
    type: String,
    required: "File URL is required"
  },
    views: {
    type: Number,
    default: 0
  },
    createdAt: {
    type: Date,
    default: Date.now
  }

fileUrl을 가지고 있으며 타입은 문자열
required가 충족되지 못하면 error msg는 File URL is required라 뜬다.
fileUrl 값이 없는 Video를 생성하면 error msg가 뜬다.

view의 타입은 숫자고이고
video가 처음 생성되면 views는 0이 되도록 설정

createdAt의 타입은 날자이고
처음 생성되면 현재의 날짜를 반환한다.

이제 이 스키마를 통해서 모델을 만들어보자
const model = mongoose.model("Video", VideoSchema);

model의 이름은 Video
Video model의 schema는 VideoSchema가 된다.

현재 database는 아직 인식하지를 못한다.
연결은 되어 있지만 거기에 model이 있는건 알지 못함.
init.js에 import 해줘야 한다.
import "./models/Video";

다음으로 알아야 할것은 data의 relationship이다.
comment에 video의 ID를 저장하거나
video가 ID의 array를 가지고 있어야 한다.

video에 comment를 달때 이 comment는 어떤 video와 직접적으로 연결되어 있는지?
두가지 방법이 있다.
한가지 방법은 여기 comment는 그대로 두고 
Video에선 모든 comment ID가 담긴 array를 추가하는거다.
object는 보통 id를 가지고 있다
따라서 모든 comment의 정보를 저장하는 대신 모든 video들이 comment id를 가지고 있는거다.
처음 video를 생성하면 comments는 0이다, 왜냐면 comment가 없기 때문
그다음 해당 video에 대한 comment를 생성하면 새로운 comment id를 video 안에 있는
comment의 list 라는 곳에 저장, 그리면 comments가 1이 된다.

Comment.js

video: {
  type: mongoose.Schema.Types.ObjectId,
  ref: "Video"
}

이 comment는 이 video와 연결되어 있고,
이 video의 type은 mongoose.Schema.Types.ObjectId
ObjectId가 어디서 온거인지 알려줘야 한다(어느 model인지)
이 경우에는 Video (ref: "Video")

두번째 방법은 ObjectId들의 array를 생성해야 한다.
ref는 Comment겠지

Video.js로 와서 comments 추가
comments: [
  {
    type: mongoose.Schema.Types.ObjectId,
    ref: "Comment"
  }
]

이렇게 두가지 선택지가 있다.
모든 CommentID들을 array로 video에 집어 넣을건지,
혹은 Comment에 연결된 Video ID를 줄것인지

이렇게 만든 모델들을 사용하기 위해선
videoController에 가서
import 해준다
import Video from "../models/Video";
이것은 model이고, element를 받는 통로이지 element가 아니다

export const home = async (req, res) => {
  const videos = await Video.find(({}))
  res.render("home", { pageTitle: "Home", videos });
};

async는 기다려주는것
await는 다음 과정이 끝날때까지 잠시 기다려 달라는것
Video.find(({})) 이렇게 하면 database에 있는 모든 video를 가져온다.
Video.find(({}))가 끝날때까지 기다린다

이렇게 하면 await 부분이 끝나기 전까지 render 부분을 실행시키지 않는다.
실패하든 성공하든 await 부분이 끝나면 다음것을 실행한다

이를 위해서 try, catch를 사용한다.
try는 우리가 해야할 것들, 그리고 만약 실패한다면 error를 잡아낸다

export const home = async (req, res) => {
  try {
    const videos = await Video.find({});
    res.render("home", { pageTitle: "Home", videos });
  } catch (error) {
    console.log(error);
    res.render("home", { pageTitle: "Home", videos: [] });
  }
};

videoUpload
우선 누군가가 우리 videoController에서 Upload하려할때 무슨일이 일어나는지 알아야함
video가 아닌 다른 file 들어오지 않도록 보호하기
upload.pug에 가서 accept="video/*" 추가

아직 send는 되지 않는다
file을 upload하고 url을 반환하는 middleware가 있어야 한다.
이 미들웨어는 multer이다

npm install multer

그리고 Upload Form의 enctype에 multipart/form-data를 추가해야 한다.
왜냐하면 file을 보내는거라 form의 encoding이 달라야 한다.

middleware 추가하기

import multer from "multer";

export const multerVideo = multer({ dest: "videos/" });

destination -> 목적지 .. 비디오가 어디에 저장될지

export const uploadVideo = multerVideo.single("videoFile");

single()은 오직 하나의 파일만 upload할수 있는걸 의미
namePart는 여기 들어올 파일의 name이다.
우리가 원하는 파일이 들어간 HTML field의 이름 부분

이후 videoRouter에 가서 uploadVideo 추가
우리가 file을 upload하면 server에 있는 video 폴더에 업로드 된다.
postUpload는 해당 file에 접근한다.
file 방식이 아닌 url로

videoController.js에서 req.file은 "videoFile"의 필드의 파일 정보이다.
file을 form으로 받아오지 않고 file 자체에서 받아온다.

export const postUpload = async (req, res) => {
  const {
    body: { title, description }, // form에서 받는 정보
    file: { path } // file 자체에서 받는 정보
    // 파일을 form에서 안받고 file 자체에서 받아옴
  } = req;
  const newVideo = await Video.create({
    fileUrl: path,
    title,
    description
  });
  res.redirect(routes.videoDetail(newVideo.id));
  // 이 newVideo는 실제 ID를 가지고 있다.

home에 갔을때 video들이 나타나지 않는데
왜냐하면 link가 망가졌기 때문
middleware에 multer dist를 수정
videos/ --> uploads/videos

MongoDB model이 한 document를 database에 저장했고,
이 document는 잘못된 url을 가지고 있다.(dist가 videos/여서 변경한 uploads/videos가 아님)
우리는 아직 Video를 수정하는 방법을 가지고 있지 않다.
MongoDB에서 어떻게 다를수 있는지 알아보자
mongo를 치고 mongo comments를 가지고 database 수정하는 방법

collections는 models 같은것
> use we-tube
switched to db we-tube
> show collections
videos
> db.videos.remove({})
WriteResult({ "nRemoved" : 4 })
> exit
bye

home의 영상이 재생이 안될건데 uploads에 대한 router가 없어서 그럼
app.use("/uploads", express.static("uploads"));
express.static()은 directory에서 file을 보내주는 middleware이다
/uploads로 가면 "uploads"라는 디렉토리로 들어간다는 의미
정확하게 이해 못하겠음 이부분

file 자체를 server에 직접 저장하는건 좋지 않다
aws 같은 곳에 저장해서 url만 불러오는 식으로 해야함

gitignore에 uploads도 추가해주자

home의 video 링크를 클릭하면 video id를 받고 video detail을 보여줘야함
videoDetail Router에서 query로 video id를 받아와야함

console.log(req.params);
req.params는 url의 param값을 가져옴
{ id: '5e4e239e5de212309c3e2100' } <-- 결과값
왜냐하면 routers에 VIDEO_DETAIL = "/:id"; 가 있어서 id로 인식함
만약 컨트롤러에서 어떤 데이터를 가지고 있다는 것을
표현하고 싶다면 더블클론(:)과 이름을 넣으면 된다.

req.params.id를 저장한 후 Video Model에서 findById에 id값을 넣어준다
const video = await Video.findById(id);

video(src=`/${video.fileUrl}`)
이렇게 앞에 /를 붙이는 이유는 서버에 있는 파일이라 그럼

editVideo를 함수화 시켜주고
videoDetail에서 routes.editVideo(video.id)로 변경

비디오 수정하기
postEditVideo를 추가해줘야 한다
이때까지 editVideo를 만들어준건 get이다.

videoDetail에서 한것과 비슷한 것을 해야함
url에서 정보를 받아와야 한다, 어떤 비디오를 수정할지 알아야함

그리고 edit video에 들어가면 title과 description이 현재의 내용으로 채워져 있어야함
이건 getEditVideo에서 할 일이다

postEditVideo는 video를 업데이트 하는것이다.

get은 뭔가를 채워넣는 작업이고, post는 업데이트하고 redirect하는 작업이다.

textarea는 value를 가지지 않는다.

form action이 video function을 가지고 있는것을 볼수 있다.
action에 해당하는 url을 수정해야한다.
form(action=`/videos${routes.editVideo()}`, method="post")
form(action=`/videos${routes.editVideo(video.id)}`, method="post") <-- 이렇게 수정
form(action=routes.editVideo(video.id), method="post")

postEditVideo 작업
await한것을 변수에 저장하지 않는다, 업데이터 하면 끝이라서(정보를 가져오지 않음)
await Video.findOneAndUpdate({ _id: id }, { title, description });
findOneAndUpdate - _id를 model에서 찾는다 그리고 title과 description을 update 해줌

비디오 삭제는 get만 있다, 왜냐면 post 할 일이 없다
누군가가 비디오 삭제를 누르면 url로 가서 이부분의 url을 가져와서 해당 비디오를 삭제

비디오를 업로드 했을때 최근에 올린것이 위에 와야 한다.
모든 비디오를 찾고 정렬을 해야한다.
const videos = await Video.find({}).sort({ _id: -1 });
-1의 의미는 위 아래 순서를 바꾸겠다는 의미다.

ESLint
Linter은 뭔가 틀린게 있으면 알려주는 친구이다

npm install eslint -g
-g 는 global하게 설치한다는 뜻, -g로 설치하면 모든 프로젝트에서 사용가능하다

eslint --init
니코버전을 설치하자
npm install eslint@5.9.0 -g

? How would you like to configure ESLint? Use a popular style guide
? Which style guide do you want to follow? Airbnb (https://github.com/airbnb/javascript)
? Do you use React? No
? What format do you want your config file to be in? JavaScript

prettier가 Formatter를 가지고 있으니코딩스타일이나 룰이 필요없다.
이를 위해서 eslint-config-prettier를 설치해줘야함
npm install eslint-config-prettier
그다음 .eslinterc.js에 추가해줘야함
module.exports = {
  extends: ["airbnb-base", "plugin:prettier/recommended"]
};

eslint 고치기
고치긴 고쳤는데 왜 고장난건지는 모르겟음
왜 고장난거지?

let videos = [];
videos는 나중에 수정될거라서 const가 아닌 let로 둔다

regular expression(정규식)은 string으로 부터 무언가를 가져오는 것이다.

내가 검색한 단어와 완전히 똑같은게 아니라 내가 넣은 단어를 포함하는걸 찾고싶다
이럴때 mongoose에 regex를 이용해야 한다.
  try {
    videos = await Video.find({
      title: { $regex: searchingBy, $options: "i" }
    });
searchingBy가 포함된 단어를 찾고 options으로 i를 줬는데 i는 insenstive(덜민감하다)를 의미
대소문자 구분 하지 않는다는 뜻

webpack - module bundler
우리가 많은 파일들을 가져와서 webpack에게 주면 그것들을 완전히 호환되는 static 파일로 변환해주는것
es6나 sass를 se5나 css로 변환해줘서 오래된 브라우저도 알아먹게 해주는것?

npm install webpack webpack-cli
설치후 webpack.config.js 생성

"start": "nodemon --exec babel-node init.js --delay 2"

"dev:server": "nodemon --exec babel-node init.js --delay 2",
"dev:assets": "webpack" --> 이러면 webpack.config.js파일의 설정값을 읽어온다
package.json의 scripts부분 변경

더이상 npm start가 아닌 npm run dev:server, npm run dev:asset를 각각의 터미널에서 해줘야 한다.
webpack.config.js에서 es6사용불가, 구형js 써야한다
webpack은 entry라고 불리는 것이 있고 output라고 불리는 것이 있다.
entry는 파일이 어디서 왔는가? 이고
output은 어디에 넣을 것인가를 의미

assets 폴더 생성
그밑에 js, scss폴더 생성
js 폴더에는 main.js, scss폴더에는 styles.scss 생성